<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ぼかし処理＆PDF結合アプリ</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
  <style>
    body { margin: 0; padding: 0; background-color: #f7f7f7; font-family: "Helvetica Neue", Arial, sans-serif; overflow-x: hidden; }
    
    /* Top Bar & Controls */
    .top-bar { background-color: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 10px 20px; position: sticky; top: 0; z-index: 100; }
    .controls-row { display: flex; flex-wrap: wrap; align-items: center; gap: 15px; justify-content: space-between; }
    .blur-controls, .action-controls { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
    .control-group { display: flex; align-items: center; gap: 5px; white-space: nowrap; }
    .control-group label { margin: 0; font-size: 13px; font-weight: bold; }
    .control-group input[type="number"] { width: 60px; text-align: center; }
    .btn-xs { padding: 2px 6px; font-size: 12px; }
    
    /* Mosaic Size Selector */
    .mosaic-size-selector { display: flex; align-items: center; gap: 8px; margin-left: 10px; }
    .mosaic-size-option { display: inline-block; border-radius: 50%; background: #ddd; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; }
    .mosaic-size-option:hover { background: #bbb; }
    .mosaic-size-option.selected { border-color: #007bff; background-color: #007bff; transform: scale(1.1); }
    
    /* Drop Zone */
    #dropZone {
      width: 98%; margin: 15px auto; min-height: 100px;
      border: 3px dashed #ccc; border-radius: 12px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      text-align: center; color: #777; background-color: #fdfdfd; transition: all 0.3s;
      cursor: pointer;
    }
    #dropZone:hover, #dropZone.dragover { background-color: #eefbff; border-color: #007bff; color: #007bff; }
    
    /* Output Area */
    #output { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; gap: 20px; }
    .canvas-wrapper { position: relative; border: 1px solid #ddd; box-shadow: 0 4px 6px rgba(0,0,0,0.1); background: #fff; overflow: hidden; line-height: 0; }
    canvas { display: block; cursor: crosshair; }
    .mosaic-indicator { position: absolute; border: 2px solid rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.1); pointer-events: none; display: none; box-sizing: border-box; z-index: 10; }
    
    /* Modals & Panels */
    .order-panel { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); z-index: 1000; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; display: none; }
    .order-panel.show { display: block; }
    .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; display: none; }
    .overlay.show { display: block; }
    
    /* Sortable List */
    #fileOrderList { list-style: none; padding: 0; margin: 10px 0; }
    #fileOrderList li { padding: 8px 12px; margin-bottom: 5px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
    #fileOrderList li:active { cursor: grabbing; }
    .drag-handle { color: #aaa; margin-right: 10px; cursor: grab; }
    
    /* Loading Spinner */
    #loadingOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); z-index: 2000; flex-direction: column; justify-content: center; align-items: center; }
    .spinner-border { width: 3rem; height: 3rem; }

    /* Responsive */
    @media (max-width: 768px) {
      .controls-row { flex-direction: column; align-items: stretch; }
      .blur-controls, .action-controls { justify-content: center; }
      .filename-input { width: 100%; }
    }
  </style>
</head>
<body>

  <div id="loadingOverlay">
    <div class="spinner-border text-primary" role="status"></div>
    <div class="mt-3 font-weight-bold" id="loadingText">処理中...</div>
  </div>

  <div class="top-bar">
    <div class="container-fluid">
      <div class="controls-row">
        <div class="blur-controls">
          <div class="control-group">
            <label><i class="fas fa-image"></i> 全体ぼかし:</label>
            <button id="decreasePixelSize" class="btn btn-outline-secondary btn-xs">-</button>
            <input type="number" id="pixelSize" value="1" min="1" class="form-control form-control-sm">
            <button id="increasePixelSize" class="btn btn-outline-secondary btn-xs">+</button>
          </div>
          <div class="control-group ml-2">
            <label><i class="fas fa-mouse-pointer"></i> 部分ぼかし:</label>
            <button id="localDecreasePixelSize" class="btn btn-outline-secondary btn-xs">-</button>
            <input type="number" id="localPixelSize" value="6" min="1" class="form-control form-control-sm">
            <button id="localIncreasePixelSize" class="btn btn-outline-secondary btn-xs">+</button>
          </div>
          <div class="mosaic-size-selector" title="部分ぼかし範囲サイズ">
            <span style="width:15px;height:15px;" class="mosaic-size-option" data-size="30"></span>
            <span style="width:25px;height:25px;" class="mosaic-size-option" data-size="60"></span>
            <span style="width:35px;height:35px;" class="mosaic-size-option selected" data-size="90"></span>
            <span style="width:45px;height:45px;" class="mosaic-size-option" data-size="120"></span>
            <span style="width:55px;height:55px;" class="mosaic-size-option" data-size="160"></span>
          </div>
        </div>
        
        <div class="action-controls" id="actionControls" style="display: none;">
          <input type="text" id="filenameInput" class="form-control form-control-sm filename-input" value="processed_files" placeholder="ファイル名" style="width: 150px;">
          <button id="downloadButton" class="btn btn-success btn-sm"><i class="fas fa-download"></i> 画像DL</button>
          <button id="toggleOrderPanel" class="btn btn-info btn-sm"><i class="fas fa-sort"></i> 順番変更</button>
          <button id="mergePdfButton" class="btn btn-primary btn-sm"><i class="fas fa-file-pdf"></i> PDF結合</button>
          <button id="resetButton" class="btn btn-danger btn-sm"><i class="fas fa-trash"></i> リセット</button>
        </div>
      </div>
    </div>
  </div>

  <div id="dropZone">
    <h4><i class="fas fa-cloud-upload-alt"></i> 画像・PDFをドロップ</h4>
    <p class="mb-0 small text-muted">またはクリックしてファイルを選択 (複数選択可)<br>Ctrl+V で貼り付けも可能</p>
  </div>
  <input type="file" id="fileInput" multiple style="display: none;" accept="image/*,application/pdf">

  <div id="output"></div>

  <div class="overlay" id="orderPanelOverlay"></div>
  <div class="order-panel" id="orderPanel">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h5 class="mb-0">ファイルの順番変更</h5>
      <button type="button" class="close" id="closeOrderPanel">&times;</button>
    </div>
    <div class="btn-group btn-group-sm w-100 mb-3">
      <button id="sortByName" class="btn btn-outline-secondary">名前順 (A-Z)</button>
      <button id="sortByNameReverse" class="btn btn-outline-secondary">名前逆順 (Z-A)</button>
    </div>
    <ul id="fileOrderList"></ul>
    <div class="text-right mt-3">
      <button class="btn btn-primary btn-sm" id="applyOrderBtn">閉じる</button>
    </div>
  </div>

<script>
    // --- Configuration & State ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    const { PDFDocument } = PDFLib;

    const state = {
        images: [], // { dataUrl, fileName, type, originalWidth, originalHeight }
        mosaicRegionSize: 90, // デフォルトを少し大きくしました
        canvasScales: new Map(), // canvasId -> scale
    };

    // --- DOM Elements ---
    const elements = {
        dropZone: document.getElementById('dropZone'),
        fileInput: document.getElementById('fileInput'),
        output: document.getElementById('output'),
        pixelSize: document.getElementById('pixelSize'),
        localPixelSize: document.getElementById('localPixelSize'),
        actionControls: document.getElementById('actionControls'),
        loadingOverlay: document.getElementById('loadingOverlay'),
        loadingText: document.getElementById('loadingText'),
        filenameInput: document.getElementById('filenameInput'),
        orderPanel: document.getElementById('orderPanel'),
        orderPanelOverlay: document.getElementById('orderPanelOverlay'),
        fileOrderList: document.getElementById('fileOrderList'),
    };

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        setupSortable();
    });

    function setupEventListeners() {
        // Drag & Drop
        elements.dropZone.addEventListener('dragover', e => { e.preventDefault(); elements.dropZone.classList.add('dragover'); });
        elements.dropZone.addEventListener('dragleave', () => elements.dropZone.classList.remove('dragover'));
        elements.dropZone.addEventListener('drop', e => { e.preventDefault(); elements.dropZone.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
        elements.dropZone.addEventListener('click', () => elements.fileInput.click());
        elements.fileInput.addEventListener('change', () => handleFiles(elements.fileInput.files));
        
        // Paste Handling (Ctrl + V)
        document.addEventListener('paste', e => {
            // モダンブラウザでは clipboardData.files に複数ファイルが入る可能性があります
            if (e.clipboardData && e.clipboardData.files && e.clipboardData.files.length > 0) {
                e.preventDefault();
                handleFiles(e.clipboardData.files);
            } 
            // 念のため items もチェック（古い仕様や一部の画像データ用）
            else if (e.clipboardData && e.clipboardData.items) {
                const files = [];
                for (let i = 0; i < e.clipboardData.items.length; i++) {
                    const item = e.clipboardData.items[i];
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        if (file) files.push(file);
                    }
                }
                if (files.length > 0) {
                    e.preventDefault();
                    handleFiles(files);
                }
            }
        });

        // Controls
        document.getElementById('increasePixelSize').onclick = () => updatePixelSize(1);
        document.getElementById('decreasePixelSize').onclick = () => updatePixelSize(-1);
        document.getElementById('localIncreasePixelSize').onclick = () => updateLocalPixelSize(1);
        document.getElementById('localDecreasePixelSize').onclick = () => updateLocalPixelSize(-1);
        
        elements.pixelSize.addEventListener('change', () => renderImages(false));

        document.querySelectorAll('.mosaic-size-option').forEach(opt => {
            opt.addEventListener('click', function() {
                document.querySelectorAll('.mosaic-size-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
                state.mosaicRegionSize = parseInt(this.dataset.size);
            });
        });

        // Action Buttons
        document.getElementById('downloadButton').onclick = downloadIndividualImages;
        document.getElementById('mergePdfButton').onclick = mergeAndDownloadPdf;
        document.getElementById('resetButton').onclick = resetApp;
        
        // Order Panel
        document.getElementById('toggleOrderPanel').onclick = openOrderPanel;
        document.getElementById('closeOrderPanel').onclick = closeOrderPanel;
        document.getElementById('orderPanelOverlay').onclick = closeOrderPanel;
        document.getElementById('applyOrderBtn').onclick = closeOrderPanel;
        document.getElementById('sortByName').onclick = () => sortImages((a, b) => a.fileName.localeCompare(b.fileName));
        document.getElementById('sortByNameReverse').onclick = () => sortImages((a, b) => b.fileName.localeCompare(a.fileName));
    }

    function setupSortable() {
        new Sortable(elements.fileOrderList, {
            animation: 150,
            handle: '.drag-handle',
            onEnd: () => {
                // Update internal state order based on DOM order
                const newOrderIndices = Array.from(elements.fileOrderList.children).map(li => parseInt(li.dataset.index));
                const reorderedImages = newOrderIndices.map(i => state.images[i]);
                state.images = reorderedImages;
                renderImages(false); // Re-render in new order
                updateOrderList(); // Re-assign indices
            }
        });
    }

    function toggleLoading(show, text = "処理中...") {
        elements.loadingOverlay.style.display = show ? 'flex' : 'none';
        elements.loadingText.textContent = text;
    }

    function updatePixelSize(delta) {
        let val = parseInt(elements.pixelSize.value) + delta;
        if (val < 1) val = 1;
        elements.pixelSize.value = val;
        renderImages(false); // Re-apply global blur
    }

    function updateLocalPixelSize(delta) {
        let val = parseInt(elements.localPixelSize.value) + delta;
        if (val < 1) val = 1;
        elements.localPixelSize.value = val;
    }

    // --- File Processing ---

    async function handleFiles(fileList) {
        if (!fileList || fileList.length === 0) return;
        toggleLoading(true, "ファイルを読み込み中...");

        try {
            const files = Array.from(fileList);
            // Process all files in parallel
            const promises = files.map(file => {
                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                    return processPdf(file);
                } else if (file.type.startsWith('image/')) {
                    return processImage(file);
                }
                return Promise.resolve([]);
            });

            const results = await Promise.all(promises);
            // Flatten the array of arrays (since PDF returns multiple pages)
            const newImages = results.flat().filter(img => img !== null);
            
            state.images = [...state.images, ...newImages];
            
            if (state.images.length > 0) {
                elements.actionControls.style.display = 'flex';
                updateOrderList();
                renderImages(true); // Initial render reset scale
            }
        } catch (error) {
            console.error("File processing error:", error);
            alert("ファイルの読み込み中にエラーが発生しました。");
        } finally {
            toggleLoading(false);
            elements.fileInput.value = '';
        }
    }

    async function processImage(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const img = new Image();
                img.onload = () => {
                    // Compress if large (> 1MB)
                    const isLarge = file.size > 1024 * 1024;
                    if (isLarge) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const scale = Math.sqrt(1024 * 1024 / file.size); // Rough estimation
                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve([{
                            dataUrl: canvas.toDataURL('image/jpeg', 0.85),
                            fileName: file.name,
                            type: 'image',
                            width: canvas.width,
                            height: canvas.height
                        }]);
                    } else {
                        resolve([{
                            dataUrl: e.target.result,
                            fileName: file.name,
                            type: 'image',
                            width: img.width,
                            height: img.height
                        }]);
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    async function processPdf(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            const pages = [];
            const baseName = file.name.replace(/\.[^/.]+$/, "");

            // Process pages sequentially to avoid memory spikes
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better quality
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
                
                pages.push({
                    dataUrl: canvas.toDataURL('image/jpeg', 0.8),
                    fileName: `${baseName}_p${i}`,
                    type: 'pdf-page',
                    width: canvas.width,
                    height: canvas.height
                });
            }
            return pages;
        } catch (e) {
            console.error("PDF Parse Error", e);
            alert(`${file.name} の読み込みに失敗しました。`);
            return [];
        }
    }

    // --- Rendering & Canvas Logic ---

    function renderImages(resetScale = false) {
        elements.output.innerHTML = '';
        state.canvasScales = resetScale ? new Map() : state.canvasScales;

        state.images.forEach((imgData, index) => {
            const container = document.createElement('div');
            container.className = 'canvas-wrapper';
            
            const canvas = document.createElement('canvas');
            canvas.id = `canvas-${index}`;
            // Set internal resolution
            canvas.width = imgData.width;
            canvas.height = imgData.height;
            
            // Draw initial image
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.src = imgData.dataUrl;
            
            img.onload = () => {
                ctx.drawImage(img, 0, 0);
                
                // Apply Global Blur
                const globalBlur = parseInt(elements.pixelSize.value);
                if (globalBlur > 1) {
                    applyMosaic(ctx, 0, 0, canvas.width, canvas.height, globalBlur);
                }
            };

            // Calculate Display Size (Scaling)
            if (resetScale) {
                const maxWidth = window.innerWidth - 40;
                const maxHeight = window.innerHeight * 0.7;
                const scale = Math.min(maxWidth / imgData.width, maxHeight / imgData.height, 1);
                state.canvasScales.set(canvas.id, scale);
            }
            
            let currentScale = state.canvasScales.get(canvas.id) || 1;
            setCanvasDisplaySize(canvas, container, currentScale);

            // Events
            attachCanvasEvents(canvas, container, ctx);

            container.appendChild(canvas);
            
            // Indicator
            const indicator = document.createElement('div');
            indicator.className = 'mosaic-indicator';
            container.appendChild(indicator);
            canvas.mosaicIndicator = indicator;

            elements.output.appendChild(container);
        });
    }

    function setCanvasDisplaySize(canvas, container, scale) {
        const w = Math.floor(canvas.width * scale);
        const h = Math.floor(canvas.height * scale);
        canvas.style.width = `${w}px`;
        canvas.style.height = `${h}px`;
        container.style.width = `${w}px`;
        container.style.height = `${h}px`;
        state.canvasScales.set(canvas.id, scale);
    }

    function attachCanvasEvents(canvas, container, ctx) {
        let isDrawing = false;

        const getCoords = (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY,
                displayX: e.clientX - rect.left,
                displayY: e.clientY - rect.top
            };
        };

        const updateIndicator = (e) => {
            const coords = getCoords(e);
            const size = state.mosaicRegionSize;
            // Indicator follows mouse, scaled to display
            const rect = canvas.getBoundingClientRect();
            const scale = rect.width / canvas.width;
            const displaySize = size * scale;
            
            const ind = canvas.mosaicIndicator;
            ind.style.width = `${displaySize}px`;
            ind.style.height = `${displaySize}px`;
            ind.style.left = `${coords.displayX - displaySize/2}px`;
            ind.style.top = `${coords.displayY - displaySize/2}px`;
            ind.style.display = 'block';
        };

        const doMosaic = (e) => {
            const coords = getCoords(e);
            const size = state.mosaicRegionSize;
            const localBlur = parseInt(elements.localPixelSize.value);
            
            // Calculate region centered on mouse
            const startX = Math.max(0, coords.x - size / 2);
            const startY = Math.max(0, coords.y - size / 2);
            const w = Math.min(size, canvas.width - startX);
            const h = Math.min(size, canvas.height - startY);

            applyMosaic(ctx, startX, startY, w, h, localBlur);
        };

        canvas.addEventListener('mousedown', e => { isDrawing = true; doMosaic(e); });
        canvas.addEventListener('mousemove', e => { 
            updateIndicator(e);
            if (isDrawing) doMosaic(e); 
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => { 
            isDrawing = false; 
            canvas.mosaicIndicator.style.display = 'none'; 
        });

        // Zoom with Wheel
        container.addEventListener('wheel', e => {
            if (e.ctrlKey) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                let scale = state.canvasScales.get(canvas.id) * delta;
                scale = Math.max(0.1, Math.min(scale, 5));
                setCanvasDisplaySize(canvas, container, scale);
                updateIndicator(e); // Update indicator size/pos
            }
        }, { passive: false });
    }

    function applyMosaic(ctx, x, y, w, h, pixelSize) {
        if (pixelSize <= 1) return;
        x = Math.floor(x); y = Math.floor(y); w = Math.floor(w); h = Math.floor(h);
        
        try {
            const imageData = ctx.getImageData(x, y, w, h);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            for (let r = 0; r < height; r += pixelSize) {
                for (let c = 0; c < width; c += pixelSize) {
                    // Get average color or just top-left pixel color
                    const pIndex = (r * width + c) * 4;
                    const red = data[pIndex];
                    const green = data[pIndex + 1];
                    const blue = data[pIndex + 2];

                    for (let dr = 0; dr < pixelSize; dr++) {
                        for (let dc = 0; dc < pixelSize; dc++) {
                            if (r + dr < height && c + dc < width) {
                                const tIndex = ((r + dr) * width + (c + dc)) * 4;
                                data[tIndex] = red;
                                data[tIndex+1] = green;
                                data[tIndex+2] = blue;
                            }
                        }
                    }
                }
            }
            ctx.putImageData(imageData, x, y);
        } catch (e) {
            console.error("Mosaic Error", e);
        }
    }

    // --- Output & Actions ---

    function updateOrderList() {
        elements.fileOrderList.innerHTML = '';
        state.images.forEach((img, index) => {
            const li = document.createElement('li');
            li.dataset.index = index;
            li.innerHTML = `<span><i class="fas fa-grip-vertical drag-handle"></i> ${img.fileName}</span> <span class="badge badge-secondary">${index + 1}</span>`;
            elements.fileOrderList.appendChild(li);
        });
    }

    function sortImages(compareFn) {
        state.images.sort(compareFn);
        renderImages(false);
        updateOrderList();
    }

    function openOrderPanel() {
        elements.orderPanel.classList.add('show');
        elements.orderPanelOverlay.classList.add('show');
    }
    
    function closeOrderPanel() {
        elements.orderPanel.classList.remove('show');
        elements.orderPanelOverlay.classList.remove('show');
    }

    function downloadIndividualImages() {
        const baseName = elements.filenameInput.value || "image";
        state.images.forEach((imgData, index) => {
            const canvas = document.getElementById(`canvas-${index}`);
            if (canvas) {
                const link = document.createElement('a');
                link.download = `${baseName}_${index+1}.jpg`;
                link.href = canvas.toDataURL('image/jpeg', 0.9);
                link.click();
            }
        });
    }

    async function mergeAndDownloadPdf() {
        toggleLoading(true, "PDFを作成中...");
        try {
            const mergedPdf = await PDFDocument.create();
            
            for (let i = 0; i < state.images.length; i++) {
                const canvas = document.getElementById(`canvas-${i}`);
                if (canvas) {
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.85);
                    const imageBytes = await fetch(dataUrl).then(res => res.arrayBuffer());
                    const image = await mergedPdf.embedJpg(imageBytes);
                    
                    const page = mergedPdf.addPage([canvas.width, canvas.height]);
                    page.drawImage(image, {
                        x: 0,
                        y: 0,
                        width: canvas.width,
                        height: canvas.height,
                    });
                }
            }
            
            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${elements.filenameInput.value || "merged"}.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        } catch (e) {
            console.error(e);
            alert("PDF作成中にエラーが発生しました");
        } finally {
            toggleLoading(false);
        }
    }

    function resetApp() {
        if(confirm("すべてリセットしますか？")) {
            state.images = [];
            state.canvasScales = new Map();
            elements.output.innerHTML = '';
            elements.actionControls.style.display = 'none';
            elements.fileInput.value = '';
        }
    }

</script>
</body>
</html>
